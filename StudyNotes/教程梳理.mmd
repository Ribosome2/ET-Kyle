[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,showJumps=`true`
---

# Root topic

## 课程介绍

## 开发环境搭建

### 特别的没有安装MonoDB Compass

## Demo运行和打包
> collapsed=`true`


### 要先编译代码再运行

### 状态同步Demo
> collapsed=`true`


#### GlobalConfig 设置AppType为Demo

#### 运行
> collapsed=`true`


##### 输入账号密码登录

##### 进入游戏后
> collapsed=`true`


###### 鼠标右键移动

###### 按 R 重载DLL

###### 按 T 进行地图传送

### 帧同步demo
> collapsed=`true`


#### AppType 选择LockStep

#### 运行
> collapsed=`true`


##### 输入账号密码登录

##### 登录成功自动切换到匹配状态
> collapsed=`true`


###### 点击match
> collapsed=`true`


####### 匹配完后进入游戏
> collapsed=`true`


######## WASD移动

###### 输入重播key

### 打包
> collapsed=`true`


#### ET/BuildTool打开打包窗口
> collapsed=`true`


##### 在这个窗口的CodeCompile部分，本质上只是对Global进行了修改

##### CodeMode
> collapsed=`true`


###### Client
> collapsed=`true`


####### 只当客户端

###### Server
> collapsed=`true`


####### 只当服务器

###### ClientServer
> collapsed=`true`


####### 同时当双端,这个模式应该只能是在编辑器下用

##### 选择完后要点击ReGenerateProjectFiles

#### HybridCLR
> collapsed=`true`


##### Install

##### GenerateAll

##### CopyAotDlls
> collapsed=`true`


###### 目标路径 Assets/Bundles/AotDlls

#### 打AB
> collapsed=`true`


##### StreamingAssets
> collapsed=`true`


###### 如果没有这个目录就创建

##### YooAsset/AssetBundleBuilder

##### 点击构建

#### 打最终包
> collapsed=`true`


##### 点击BuildEditor的BuildPackage

##### 生成完会生成在Release目录下

### 运行单独的服务器
> collapsed=`true`


#### Rider打开ET\.sln

#### 编译

#### 运行生成的DotNet\.App

## ECS组件式编程
> collapsed=`true`


### ET框架中的ECS编程原则
> collapsed=`true`


#### 实体即组件，组件即实体

#### 如果要编写一个新的实体或者组件，绝不继承除Entity之外的任何父类

#### 绝不使用任何的虚函数，使用逻辑分发替代

#### Model 和ModelView只存放实体和组建的额数据字段声明，如非必要绝不放任何逻辑函数

#### Hotfix和HotfixView中只保留纯逻辑函数，也就是使用静态类的拓展方法<br/>编写System,且绝不允许声明任何数据字段

#### Model和Hotfix项目绝不运行出现跟Unity引擎相关的游戏对象类和调用相关API函数

#### 如实体或者组件有数据字段声明，必须编写相关的声明周期函数<br/>以防实体对象池回收再利用导致逻辑错误

### 代码工程划分
> collapsed=`true`


#### AllHofix
> collapsed=`true`


##### 这个工程里面不能定义类，（类的定义放在AllModel里面）只能用拓展类

#### AllModel
> collapsed=`true`


##### Model不能包含任何引擎相关的代码

##### ModelView作为表现层，可以引用引擎相关代码

##### CodeMode选择决定Server或者Client目录是否会在Rider解决方案显示
> collapsed=`true`


###### Server目录

###### Client目录

###### Share目录

#### 代码的命名空间规定
> collapsed=`true`


##### 如果是在Server目录下，那就是ET\.Server

##### 如果在Client目录下，就是ET\.Client

##### 如果两端都要，就只用ET

### 相关Attribute
> collapsed=`true`


#### ComponentOf

#### ChildOf
> collapsed=`true`


##### 声明是什么类型的Entity的子Entity

#### EntitySystemOf
> collapsed=`true`


##### 声明是什么类型的Component的System

#### FriendOf
> collapsed=`true`


##### 要修改其它组件的属性，就要加这个属性

### AddChild
> collapsed=`true`


#### 用来添加子实体，可以添加任意个

### AddComponent
> collapsed=`true`


#### 同类型的组件只能挂一个

### System代码的编写
> collapsed=`true`


#### 代码放在AllHotfix里面

#### 里面还用了C\#的源代码生成器技术来自动生成使用System代码的代码
- LINK
<pre>https://learn.microsoft.com/zh-cn/dotnet/csharp/roslyn-sdk/source-generators-overview</pre>

#### 先定义System的EntitySystemOf之后，按Alt\+Enter生成component对应的生命周期函数

#### 如果要在System里面修改组件的属性，要加FriendOf

## 虚拟进程Fiber

### 先讲了Init的启动逻辑

#### Unity\.Loader项目的作为不能主包的代码不能热更，改了之后要重新生成HybridCLR

#### World类
> fillColor=`#FF5600`


##### 作为单例的容器，用来添加各种非ECS模式的代码单例

###### Logger

###### TimeInfo

###### FiberManager
> fillColor=`#00C8FF`


####### 本节的关键内容

####### Fiber
> fillColor=`#00C8FF`


######## 本质上是一个类
> fillColor=`#00C8FF`


######## Root
> fillColor=`#00C8FF`


######### 是某个Scene
> fillColor=`#00C8FF`


###### ResourceComponent

####### 资源加载

###### CodeLoader

####### 热更代码

######## Hotfix\.dll Model\.dll

######## Hotfix\.pdb,Model\.pdb

####### 热更完后会创建CodeTypes单例

######## CodeTypes\.Instance\.CreateCode\(\);<br/>会创建可以热重载的代码

####### 通过反射调用ET\.Entry\.Start的函数

### 为什么引入Fiber概念

#### 为了多线程性能利用

#### 利用多个核心，起多个主线程

#### 设计上规避了多个线程竞争同一个资源

#### EntitySystem驱动生命周期函数

#### Fiber的三种Update方式

##### Main

###### 主线程调度

####### 按顺序调用Fiber

##### Thread

###### 游戏进程（process\) 固定线程方式进行调度

####### 性能调试的时候用

###### 每个线程只调用一个fiber

##### ThreadPool

###### 游戏进程，线程池方式进行调度

####### 上线的时候用这种，最大性能

###### 同一个Fiber在不同的时间段被不同的线程调用

###### 同一个Fiber在同一时间只会被一个线程调用

## Scene层级关系

### 创建Fiber的时候会创建一个和Fiber相互引用的Scene

### Scene作为容器，可以挂载各种组件

### 也可以作为逻辑上下文

### EntityHelper 工具类

#### Entity\.Scene 获取最近的Scene

#### Entity\.Root获取根部的Scene

##### 这里就明确能知道Scene是可以和组件相互嵌套的

## 事件订阅和发布

### 事件的定义文件有好几个

#### Share/Demo/EventType\.cs

##### 文件放在Share目录下，命名空间确实ET\.Client<br/>只有前端用，为什么要放在Share目录

#### Server/Module/AOI/AOIEventType

#### LockStepEventType

#### MoveEventType

#### UnitEventType

### 事件的定义本质只是声明struct类型而已，只要在AllModel目录下<br/>选一个目录创建后缀为EventType的文件声明就行

### 事件的处理类都继承自AEvent

#### 第一个参数基本都是Scene,第二个是上面定义的事件结构体

#### 写好后Alt\_Enter生成Run函数

#### 处理类要加Event Attribute类说明SceneType

### 抛出事件的两种方式

#### EventSystem\.Instance\.PublishAsync

##### 可以用await等待事件处理完

#### EventSystem\.Instance\.Publish\(\)

##### 同步方式，不会等事件处理完

## ETTask异步编程

### C\#的异步函数

#### async和await是C\#5\.0引入的关键字

### ETTask

#### 跟C\#自带的Task类有上面区别？

## 网络消息的定义
> collapsed=`true`


### ET 8\.0之前是用Protobuf

### 8\.0只会用MemoryPack
> collapsed=`true`

- LINK
<pre>https://github.com/Cysharp/MemoryPack</pre>

#### 消息定义还是用\.proto的格式

#### 用ET框架提供的Proto2CS工具来生成<br/>符合MemoryPack序列化格式的C\#代码对象
> collapsed=`true`


##### 项目代码在ET\.sln的的Share\.Tool目录

### Proto定义文件路径
> collapsed=`true`


#### Assets/Config/Proto

#### 文件分类
> collapsed=`true`


##### ClientMessage\_C
> collapsed=`true`


###### 客户端Fiber之间通讯

##### InnerMessage\_S
> collapsed=`true`


###### 服务器内部之间通信的协议

##### LockStepInner\_S
> collapsed=`true`


###### 帧同步服务端内部通信

##### LockStepOuter\_C
> collapsed=`true`


###### 帧同步客户端和服务端之间

##### OuterMessage\_c
> collapsed=`true`


###### 常规的客户端和服务端之间通信的协议

### proto文件语法
> collapsed=`true`


#### message开头表示一个协议体
> collapsed=`true`


##### message\+协议名\+空格\+//\+空格\+消息接口 
> collapsed=`true`


###### 注意空格一定要留

###### 例子：message C2R\_LoginAccount // ISessionRequest

###### 消息接口类型
> collapsed=`true`


####### ISessionRequest

####### ISessionResonse
> collapsed=`true`


######## 一定要有RpcId,Error,Message三个变量

##### 向上一行//ResonseType\+空格\+返回协议名来定义协议的返回协议类型

#### 等号 "=" 两边一定要留空格

### 生成协议
> collapsed=`true`


#### BuildEditor窗口Proto2CS按钮

#### 生成的协议在proto文件名对应的\.cs文件里面，并不是每个协议单独一个文件

#### 生成的代码也是分部类（partial\),也用了源代码生成器技术生成完整的类代码

## 服务端的连接流程

### 前置连接流程
> collapsed=`true`


#### SceneType
> collapsed=`true`


##### Assets/Config/Excel/StartConfig/Localhost/StartSceneConfig@s\.xlsx <br/>里面配置决定每个服务器的SceneType
> align=`left`,collapsed=`true`


###### StartSceneConfig页签
> collapsed=`true`


####### 每一行配置表示一个要创建一个虚拟进程（纤程Fiber\)

###### Router页签

#### 通信流程图
> collapsed=`true`

- FILE
<pre>StudyNotes/流程图/通信架构图.drawio</pre>

##### RouterManager服务器只在开发时存在，实际发布后由CDN缓存服务器代替

##### 里面包含的就是ET的软路由设计

#### 各种服务器的功能
> collapsed=`true`


##### Router
> collapsed=`true`


###### 中转客户端和游戏服务器事件的消息

##### Realm服务器
> collapsed=`true`


###### 就是网关负载均衡服务器，接收Router请求，分配合适的Gate服务器地址给Router

##### Gate服务器
> collapsed=`true`


###### 由Realm网关负载均衡服务器分配，和Router通信

###### 这种服务器上会创建按玩家Unit映射实体
> collapsed=`true`


####### 但是不应该把业务逻辑都写在这个服务器，二应该在Map服务器上

##### Map服务器
> collapsed=`true`,fillColor=`#EDA3A3`


###### Gate网关服务器的映射实体传送到Map服务器后，<br/>后续所有的业务逻辑都由Map服务器上的Unit映射实体进行处理
> collapsed=`true`


####### 这里的传送的含义？

###### 可以理解为这个就是GameServer
> fillColor=`#EDA3A3`


##### Location定位服务器
> collapsed=`true`


###### 不管时Player映射实体，还是Unit实体，都会向<br/>Location服务器注册和更新ActorId（位置信息）

###### 简单来说这个就是用来查对应的玩家在哪个Map服务器？

## Actor模型与纤程通讯

### Unit映射对象实体

#### Unit之间怎么确定其它的Unit的具体位置

##### ActorId类

###### InstanceId

####### 用来定位具体的Actor邮箱

###### Address

####### Process

######## 进程

####### Fiber

###### 用来定位到具体的进程，具体纤程，具体Actor

### Actor模型

#### 每个Actor都由自己的状态，行为和邮箱

#### 消息传递

##### 通过邮箱传递

#### 无状态共享

##### 隔离性提供了安全的处理状态，不需要考虑多线程编程中的锁状态

#### 并发性

##### Actor可能会阻塞自己处理的逻辑，但是不会阻塞自己允许的线程<br/>所以多个Actor可以同时进行消息传递和消息事件处理

### 同一进程内的两个纤程通过消息队列来进行通讯

#### ProcessInnerSender（这个组件本质就是一个消息队列）

### 不同进程间通过NetInner Fiber进行网络通讯

## 登录流程

### 一

#### 演示设置

##### CodeMode改成ClientServer

##### AppType为Demo

#### 点击登录流程开始按钮

##### UILoginComponentSystem

###### 点击按钮调用LoginHelper\.Login

####### ClientSenderComponent

##### Main2NetClient\_LoginHandler

###### 所有的处理类都是用协议名\+Handler的约定

#### 这节基本就是讲 Main纤程到NetClient纤程的流程

### 二

#### Main2NetClient\_LoginHandler运行逻辑

##### RouterAddressComponent

###### 每次都会移除旧的创建一个新的组件实例

###### 返回从Realm服务器地址

##### 根据上面的Realm地址创建一个Session

###### NetComponent\.CreateRouterSession

##### Session发C2R\_Login后得到结果

###### 服务器C2R\_LoginHandler
- FILE
<pre>Unity/Assets/Scripts/Hotfix/Server/Demo/Realm/C2R_LoginHandler.cs</pre>

####### 随机分配一个Gate

##### 用上面返回的R2C\_Login创建GateSession

###### 添加SessionComponent

#### 这节讲了C2R和R2C的代码流程，没有加任何代码

### 三

## 实战系列
