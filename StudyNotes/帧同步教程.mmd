[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,showJumps=`true`
---

# Root topic

## 状态同步

### 逻辑计算在服务器

### 服务器同步变化给客户端

### 客户端只做表现

## 帧同步

### 服务器广播客户端指令

### 逻辑计算在客户端逻辑层

### 客户端逻辑层发送变化给表现层

### 相当与吧状态同步的服务器挪到了客户端逻辑层
> fillColor=`#00FF5B`


#### 怎么保证不同的端计算出的结果是一样的

##### 定点数

### 帧同步适合场景

#### 操作少，逻辑变化多

#### 同场景玩家数少

#### 同视野单位特别多的场合

#### 只适合开房间的类型

#### 不太需要单位信息保密的场景

##### 比如棋牌游戏，不能让客户端知道其它玩家的所有牌的信息

##### Moba也不适合，比如不希望客户端知道其它玩家的视野信息

#### 以上条件缺一不可

### 帧同步优势

#### 流量少

#### 录像文件小

#### 服务器不做验证的话，服务器的消耗就小

### 帧同步误区

#### 手感更好

#### 开发简单，难度低

#### 对网络速度要求低

#### 各个客户端的表现一模一样

#### 可以减少服务器

### 帧同步的几种方案

#### 1 服务器消息驱动帧同步

##### 服务器固定帧率收集消息，定时广播<br/>客户端指令没有真的概念，帧是由服务器消息驱动的<br/>适合玩家数量较多的场景，预测只能做表现层的预测，<br/>开发难度相对简单

#### 2\.预测回滚帧同步

##### 服务器固定真理收集消息，客户端也有自己的帧，<br/>适合2\-3人的场景，逻辑层有座预测，预测失败则回滚，开发难度大

## 网络0GC
> leftSide=`true`


### 0 GC的方式

#### 1\.MessagePool

#### 2\.MemoryPack提供了ref的反序列化方式

#### 3\.消息中的成员回收

#### 4\.消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct
> leftSide=`true`


#### MemoryStream GC消除

#### UDP Send Recv GC消除

### 0GC的消除策略

#### 有风险

#### 服务端不消除GC
> leftSide=`true`


##### 不重用协议

#### 客户端手动消除消息GC

### 消息的创建回收

#### MessageObject\.IsFromPool

#### 发送消息时创建，消息传到网络层序列化完成后回收

##### a\. 发送的适合需要自己调用Create\(true\)

##### b\.回收时框架自动调用Dispose\(\)
> leftSide=`true`


#### 接受消息时创建，消息传到主线程使用完成后回收
> leftSide=`true`


##### 接受消息的适合框架自动调用FetchMessage

##### 回收需要自己调用Dispose
> leftSide=`true`


### MemoryBuffer创建回收
> leftSide=`true`


### MemoryPack Sou
> leftSide=`true`

