[Scia Reto](https://sciareto.org) mind map   
> __version__=`1.1`,showJumps=`true`
---

# Root topic

## 状态同步

### 逻辑计算在服务器

### 服务器同步变化给客户端

### 客户端只做表现

## 帧同步

### 服务器广播客户端指令

### 逻辑计算在客户端逻辑层

### 客户端逻辑层发送变化给表现层

### 相当与吧状态同步的服务器挪到了客户端逻辑层
> fillColor=`#00FF5B`


#### 怎么保证不同的端计算出的结果是一样的

##### 定点数

### 帧同步适合场景

#### 操作少，逻辑变化多

#### 同场景玩家数少

#### 同视野单位特别多的场合

#### 只适合开房间的类型

#### 不太需要单位信息保密的场景

##### 比如棋牌游戏，不能让客户端知道其它玩家的所有牌的信息

##### Moba也不适合，比如不希望客户端知道其它玩家的视野信息

#### 以上条件缺一不可

### 帧同步优势

#### 流量少

#### 录像文件小

#### 服务器不做验证的话，服务器的消耗就小

### 帧同步误区

#### 手感更好

#### 开发简单，难度低

#### 对网络速度要求低

#### 各个客户端的表现一模一样

#### 可以减少服务器

### 帧同步的几种方案

#### 1 服务器消息驱动帧同步

##### 服务器固定帧率收集消息，定时广播<br/>客户端指令没有真的概念，帧是由服务器消息驱动的<br/>适合玩家数量较多的场景，预测只能做表现层的预测，<br/>开发难度相对简单

#### 2\.预测回滚帧同步

##### 服务器固定真理收集消息，客户端也有自己的帧，<br/>适合2\-3人的场景，逻辑层有座预测，预测失败则回滚，开发难度大

## 第二节 网络0GC
> leftSide=`true`


### 0 GC的方式

#### 1\.MessagePool

#### 2\.MemoryPack提供了ref的反序列化方式

#### 3\.消息中的成员回收

#### 4\.消息中容器回收，MemoryPack会对容器调用Clear，容器中最好是struct
> leftSide=`true`


#### MemoryStream GC消除

#### UDP Send Recv GC消除

### 0GC的消除策略

#### 有风险

#### 服务端不消除GC
> leftSide=`true`


##### 不重用协议

#### 客户端手动消除消息GC

### 消息的创建回收

#### MessageObject\.IsFromPool

#### 发送消息时创建，消息传到网络层序列化完成后回收

##### a\. 发送的适合需要自己调用Create\(true\)

##### b\.回收时框架自动调用Dispose\(\)
> leftSide=`true`


#### 接受消息时创建，消息传到主线程使用完成后回收
> leftSide=`true`


##### 接受消息的适合框架自动调用FetchMessage

##### 回收需要自己调用Dispose
> leftSide=`true`


### MemoryBuffer创建回收
> leftSide=`true`


### MemoryPack Sou
> leftSide=`true`


## 第三节 框架层的调整
> leftSide=`true`


### 为了帧同步对框架的修改

#### 1\.EntityRef

##### 对InstanceId进行封装，而且是弱引用

##### 当InstanceId不一致的时候，返回null
> leftSide=`true`


###### 解决Entity引用其它的Enity,当其它Enity<br/>被Dispose的时候，应该返回Null的问题

#### 2\.Entity不再统一注册到Root中，只有Actor对象挂载了MailBoxComponent的<br/>注册到ActorMessageDispatcherComponent中

#### 3\.TypeSystemm

##### EntitySystemSingleton,可拓展的EntitySystem机制

##### 例子:LSEntitySystemSingleton

#### 4\.Domain改成了IScene接口，更完善Scene的代码都简化了
> leftSide=`true`


#### 5\.Entity中Components改成SortedDictionnary,保证有序
> leftSide=`true`


##### 比如两个端执行删除，要保证顺序一致

#### 6\.Mongo序列化BeginInit,SerializeSystem
> leftSide=`true`


##### Entity的componentsDB

#### 7\.配置文件改成了Bson，直接支持Dictionary
> leftSide=`true`


## 第四节 帧同步的架构
> leftSide=`true`


### 进房间流程
- FILE
<pre>StudyNotes/流程图/进房间消息流程.drawio</pre>

## 第五节，LSEntity
> leftSide=`true`


### 为什么要LSEntity

#### 1\.限制Entity的Id生成

##### 要保证不同的端Id一致

#### 2\.LSWorld不能使用Update,LateUpdate Load等等

#### 3\.序列化和反序列化导致InstanceId跟System绑定失效，<br/>不能写一个老式的FixedUpdate

#### 4\.用Id 跟System绑定，专用的LSUpdateSystem

#### 5\.可以针对LSEntity,加上float分析器限制

### LSWorld:LSEntity

#### 1\.定点数部分，纯逻辑层

#### 2\.序列化反序列化，回滚的部分

#### 3\.Id生成器

#### 4\.随机数
> leftSide=`true`


#### 5\.LSUpdater
> leftSide=`true`


##### 注意，这个不是fixedUpdate,记录有哪些Entity有LSUpdate

### System
> leftSide=`true`


#### LSEntitySystemSingleton

#### LSUpdateSystem
> leftSide=`true`


#### LSRollbackSystem
> leftSide=`true`


### LSUpdater\.Update驱动
> leftSide=`true`


#### Room上挂有一个Updater组件，在固定帧调用LSWorld的Updater

## 第六节 预测回滚
> leftSide=`true`


### Room

#### FrameBuffer 输入缓存

##### 记录每个人的输入

#### FixedTimeCounter 固定时间计算，固定时间可以改变
> leftSide=`true`


#### LSWorld Child可以多个

#### PredictionFrame 预测帧，AuthorityFrame 权威帧
> leftSide=`true`


### LSServerUpdater

#### 服务端的驱动

### LSClientUpdater
> leftSide=`true`


### 预测

#### 作用：

##### 1\.本地立即响应

##### 2\.其它发送操作给服务端，服务端的帧到了可以马上广播
> leftSide=`true`


#### 策略
> leftSide=`true`


##### 1\.客户端预测自己的输入，直接获取

##### 2\.客户端预测别人的输入，取上一帧的输入
> leftSide=`true`


##### 3\.服务的预测，时间到了，客户端的输入没有发送过来，<br/>直接取客户端的上一帧输入，相当于丢弃客户端的输入
> leftSide=`true`


#### 权威消息处理

##### 1\.权威消息比预测消息早

###### 直接用权威帧覆盖

##### 2\.权威帧和预测帧一样
> leftSide=`true`


###### 基本上就不需要处理，只是发hash给服务器对比

##### 3\.权威消息和预测消息不一致
> leftSide=`true`


###### 进行回滚

####### 拿缓存的LSWorld反序列化，并且重现计算预测帧

## 第七节
> leftSide=`true`


### 客户端时间碰撞收缩\(原理看似简单，但是很耗思考）

#### 为什么要动态调整客户端Update时间

##### 为了要让客户端的帧比服务端的帧要提前一点点

#### 动态调整客户端fixedtime

##### 每秒钟，服务的发送客户端的时间延迟时间给客户端<br/>Room2C\_AdjustUpdateTime，在一秒内调整完成

##### 比如是两帧的差距，如果大了，叫客户端慢一点，<br/>如果小了，就叫客户端快一点

##### 新的一帧时间= \(1帧时间 \+\(diffTime \- 1帧时间\)\)/\(1000/1帧时间\)

### 不同步检测

#### FrameMessageHandler

## 第八节 录像信息
> leftSide=`true`


### 1\.记录初始化信息

### 2\.记录每帧输入
> leftSide=`true`


### 3\.定期记录LSWorld的序列化
> leftSide=`true`


#### 为了支持随意拖放，加快录像的播放，回放速度<br/>比如每分钟记录一次

### LSReplayUpdater
> leftSide=`true`


## 第九节 断线重连
> leftSide=`true`


### C2G\_LoginGateHandler

### G2C\_ReconnectHandler
> leftSide=`true`


#### 进行场景的切换
